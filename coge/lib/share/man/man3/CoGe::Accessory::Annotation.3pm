.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "CoGe::Accessory::Annotation 3"
.TH CoGe::Accessory::Annotation 3 "2015-05-06" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SS "new"
.IX Subsection "new"
.Vb 10
\& Usage    :  my $annot = new  Annotation(Type=>"",Values=>"").
\& Purpose  :  creates an instance of the
\&             Annotation object. This object
\&             has 2 attributes,Type and
\&             Values.The Type attribute
\&             of the object is set to
\&             the value the user inputs.
\&             If there\*(Aqs no user input ,
\&             a default value \*(Aqunknown\*(Aq
\&             is used.  The Values attribute
\&             is initialized to an empty
\&             array. Besides Type, if there
\&             are additional args that are
\&             passed in, they are collected
\&             into the values array.The user
\&             can pass a string, array or ref
\&             to an array as values to the
\&             Values attribute. The Values
\&             attribute is set by calling
\&             the add_Annot method on every
\&             element of the values array.
\&             add_Annot method is also called
\&             to condense objects of same
\&             type into a single object.
\& Argument : The user can give args Type and
\&            Values or either of them, but the
\&            should always have the key \*(AqType\*(Aq
\&            or \*(AqValues\*(Aq.
.Ve
.SS "add_Annot"
.IX Subsection "add_Annot"
.Vb 9
\& Usage     :   $annot\->add_Annot($args) ;
\& Purpose   :   This method is meant to add
\&               values to the Values attribute,
\&               In the first step, collects
\&               all the args that have been
\&               passed into an array, if any
\&               of the args is an array ref,
\&               it is dereferenced and the
\&               array is stored.
\&
\&               Each of these args is checked
\&               for its data type; If it is an
\&               Annotation object, a check is
\&               performed to see if any of the
\&               values already existing in the
\&               Values attribute of the main
\&               objects are also objects of the
\&               same Type as the Type of the
\&               object being added, if true,
\&               it then just appends the values
\&               of the arg object to the Values
\&               attribute of the main object.
\&               If not true, it then adds
\&               an additional element to the
\&               Values attribute array of the
\&               main object.
\&
\&               If the value being added is
\&               not an Annotation object, then
\&               it gets pushed into the Values
\&               attribute array.
\& Argument  :   can be an array, ref to an array, another
\&               Annotation object or a string.
.Ve
.SS "to_String"
.IX Subsection "to_String"
.Vb 9
\& Usage     :  my $str = $annot\->to_String(\*(Aq&\*(Aq) ;
\& Purpose   :  Returns the elements in the Values array as
\&              a single string,the Values array can contain
\&              other Annotation objects, string variables
\&              or another array as its elements.The
\&              function first checks for the data type
\&              of each element.If the element is another
\&              Annotation object, the function is called
\&              recursively on the nested Annotation object.
\&
\&              Else, if the element is an ARRAY,
\&              each element of this internal array
\&              is again checked for its data type, if
\&              again an Annotation object is present,
\&              same as above.If the internal element is
\&              an array, Perl\*(Aqs join() is used to concat
\&              the elements of the internal array into a
\&              string.If the elements are string variables
\&              themselves,they are concated to the main
\&              string variable that is being returned.
\&              Else, if the element is a HASH,the key
\&              value pairs of each entry are joined into a
\&              string and concated to the main string being
\&              returned.  Else, if the element is a string
\&              itself, it is joined to the main string
\&              thats returned.  Every elemnt is separated
\&              by inserting a deliomiter in between.
\&
\& Argument  : A delimiter(optional)
.Ve
.SS "has_a"
.IX Subsection "has_a"
.Vb 7
\& Usage     :  my $bool = $annot\->has_a($search_term);
\& Purpose   :  Return true if the the Values of the
\&              annotation object contains other annotation
\&              object(s) of type equal to the search term,
\&              else returns false.
\& Returns   :  a boolean.
\& Argument  :  Requires the search term
.Ve
.SS "is_a"
.IX Subsection "is_a"
.Vb 6
\& Usage     : $annot\->is_a($search_term) ;
\& Purpose   : Checks if the given search term equal to
\&             the Type attribute of the annotation object
\&             that the method is called on.
\& Returns   : a boolean.
\& Argument  : Requires the search term
.Ve
.SS "get_by_type"
.IX Subsection "get_by_type"
.Vb 10
\& Usage     :  my $type_object = $annot\->get_by_type(\*(Aqsearchterm\*(Aq);
\&              OR  my @type_Arr = $annot\->get_by_type(\*(Aqsearchterm\*(Aq);
\& Purpose   :  If the Values attribute of
\&              the annotation object contains
\&              another annotation object(s)
\&              of the type equal to the
\&              search term, it is pushed into
\&              the return array.The array
\&              is returned.
\& Returns   :  An array( OR its reference) of Annotation
\&              objects whose Type attribute is same as
\&              the search term entered by the user.
\& Argument  :  search type
.Ve
.SS "next"
.IX Subsection "next"
.Vb 10
\& Usage     : while(my $next = $annot\->next()){ .... }
\& Purpose   : Returns each of the elements of the Values
\&             attribute array, if an element in the array
\&             is not an Annotation object, it creates
\&             an Annotation object of Type=>unknown and
\&             the Values attribute of the newly created
\&             object will be assigned the value of the
\&             element in the array.
\& Returns  :  Each element in the Values attribute as an
\&             Annotation Object
.Ve
.SS "count"
.IX Subsection "count"
.Vb 5
\& Usage     : my $count = $annot\->count() ;
\& Purpose   : returns the number of elements in the
\&             Values attribute array
\& Returns   : a number
\& Argument  : none
.Ve
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
.Vb 4
\& Usage     :
\& Purpose   :
\& Returns   :
\& Argument  :
.Ve
.SH "NAME"
Annotation \- Annotation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Annotation
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "USAGE"
.IX Header "USAGE"
.SH "BUGS"
.IX Header "BUGS"
.SH "SUPPORT"
.IX Header "SUPPORT"
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&        Eric Lyons
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
